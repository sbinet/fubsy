// Copyright Â© 2012, Greg Ward. All rights reserved.
// Use of this source code is governed by a BSD-style license that can
// be found in the LICENSE.txt file.

package dag

import (
	"fubsy/types"
)

// hmmm: this is really the *build* state of a given node
type NodeState byte

const (
	// the default state for all nodes
	UNKNOWN NodeState = iota

	// this is a source node, so it doesn't make sense to have a build
	// state; this state just exists because it looks smarter than
	// UNKNOWN. not sure if we really need it...
	SOURCE

	// this node is currently building
	BUILDING

	// the attempt to build this node failed
	FAILED

	// we did not try to build this node, because building one of its
	// ancestors failed
	TAINTED

	// this node was successfully built
	BUILT
)

var statenames []string

func init() {
	statenames = []string{
		"UNKNOWN", "SOURCE", "BUILDING", "FAILED", "TAINTED", "BUILT"}
}

func (self NodeState) String() string {
	return statenames[int(self)]
}

// This interface must not betray anything about the filesystem,
// otherwise we'll have no hope of making non-file nodes. (They're not
// needed often, but when you need them you *really* need them.)
type Node interface {
	types.FuObject

	// brief human-readable string representation of this node (must
	// be unique in this graph)
	Name() string

	// N.B. it's perfectly reasonable for String() and Name() to
	// return the same thing, but some Node types have to resort to
	// using cryptic unique IDs as their Name(), so String() can be
	// helpful in presenting those nodes to the user -- the important
	// thing is that String() does not *necessarily* return a unique
	// representation, whereas Name() does

	// Set the BuildRule that tells how to build this node (i.e. for
	// which this node is a target). Non-target nodes (original
	// sources) have no BuildRule.
	SetBuildRule(rule BuildRule)

	// Return the build rule previously passed to SetBuildRule() (nil
	// if no rule has ever been set, which implies that this is an
	// original source node).
	BuildRule() BuildRule

	// Expand() generates new nodes that represent the same resources
	// as this node, only more concretely. Returns nil if no expansion
	// is necessary (the normal case). Canonical use case: expanding
	// wildcards by replacing one GlobNode with zero or more
	// FileNodes. Note that Node.Expand() implementations are
	// responsible only for creating new Node objects, *not* for
	// wiring them into the DAG. That happens in DAG.Rebuild(), which
	// has the option of reusing existing Nodes in the DAG and
	// dropping Nodes generated by Node.Expand() on the floor. Also,
	// DAG.Rebuild() by default drops the Node on which Expand() was
	// called; implemenations that want to preserve themselves must
	// include themselves in the return list of replacement Nodes.

	// return true if the resource represented by this node already
	// exists -- we don't care if it's stale or up-to-date, or whether
	// it has changed or not... simply, does it exist? (non-existence
	// is a short-circuit that means we don't have to check if parent
	// nodes have changed, because of course we have to rebuild this
	// node)
	Exists() (bool, error)

	// return true if this node has changed since the last build where
	// it was relevant
	Changed() (bool, error)

	SetState(state NodeState)

	State() NodeState
}

// a build rule relates source(s) to target(s) by way of action(s)
type BuildRule interface {
	// Run this rule's action(s) to build its targets from their
	// sources. Return the rule's list of target nodes, whether they
	// built successfully or not, and an error. Caller must not mutate
	// targets, since it may be internal state of the BuildRule.
	Execute() (targets []Node, err error)

	// Return a string describing this rule's action(s).
	ActionString() string
}

// Convenient base type for Node implementations -- provides the
// basics right out of the box. Real Node implementations still have
// to take care of:
//   Equal()
//   Exists()
//   Changed()

type nodebase struct {
	name  string
	rule  BuildRule
	state NodeState
}

func makenodebase(name string) nodebase {
	return nodebase{
		name: name,
	}
}

func (self *nodebase) Name() string {
	return self.name
}

func (self *nodebase) SetBuildRule(rule BuildRule) {
	self.rule = rule
}

func (self *nodebase) BuildRule() BuildRule {
	return self.rule
}

func (self *nodebase) Expand(ns types.Namespace) (types.FuObject, error) {
	return nil, nil
}

func (self *nodebase) SetState(state NodeState) {
	self.state = state
}

func (self *nodebase) State() NodeState {
	return self.state
}

// some methods to implement FuObject

func (self *nodebase) String() string {
	return self.name
}

func (self *nodebase) CommandString() string {
	return types.ShellQuote(self.name)
}
