package dag

import (
	"fubsy/types"
)

// hmmm: this is really the *build* state of a given node
type NodeState byte

const (
	// the default state for all nodes
	UNKNOWN NodeState = iota

	// this is a source node, so it doesn't make sense to have a build
	// state; this state just exists because it looks smarter than
	// UNKNOWN. not sure if we really need it...
	SOURCE

	// this node is currently building
	BUILDING

	// the attempt to build this node failed
	FAILED

	// we did not try to build this node, because building one of its
	// ancestors failed
	TAINTED

	// this node was successfully built
	BUILT
)

// This interface must not betray anything about the filesystem,
// otherwise we'll have no hope of making non-file nodes. (They're not
// needed often, but when you need them you *really* need them.)
type Node interface {
	// brief human-readable string representation of this node (must
	// be unique in this graph)
	Name() string

	// human-readable string representation of this node that is not
	// necessarily unique; it's perfectly reasonable for String() and
	// Name() to return the same thing, but some Node types have to
	// resort to cryptic unique IDs Name(), so String() can be helpful
	// in presenting those nodes to the user
	String() string

	// return the child nodes that depend on this node
	//Children() []Node

	// Set the action that must be executed to build this node from
	// its parents. (This is a single Action because actions can be
	// compound: in particular, SequenceAction is an implementation of
	// Action that is just a sequence of other Actions.)
	SetAction(action Action)

	// Return the action previously passed to SetAction() (nil if no
	// action has ever been set, which implies that this is an
	// original source node).
	Action() Action

	// Generate new nodes that represent the same resources as this
	// node, only more concretely. Return nil if no expansion is
	// necessary (the normal case). Canonical use case: expanding
	// wildcards by replacing one GlobNode with zero or more
	// FileNodes. Note that Node.Expand() implementations are
	// responsible only for creating new Node objects, *not* for
	// wiring them into the DAG. That happens in DAG.Rebuild(), which
	// has the optoin of reusing existing Nodes in the DAG and
	// dropping Nodes generated by Node.Expand() on the floor. Also,
	// DAG.Rebuild() by default drops the Node on which Expand() was
	// called; implemenations that want to preserve themselves must
	// include themselves in the return list of replacement Nodes.
	Expand(dag *DAG, ns types.Namespace) ([]Node, error)

	// return true if this node and other describe the same resource
	// (it's often sufficient to compare names)
	Equal(other Node) bool

	// return true if the resource represented by this node already
	// exists -- we don't care if it's stale or up-to-date, or whether
	// it has changed or not... simply, does it exist? (non-existence
	// is a short-circuit that means we don't have to check if parent
	// nodes have changed, because of course we have to rebuild this
	// node)
	Exists() (bool, error)

	// return true if this node has changed since the last build where
	// it was relevant
	Changed() (bool, error)

	SetState(state NodeState)

	State() NodeState
}


// Convenient base type for Node implementations -- provides the
// basics right out of the box. Real Node implementations still have
// to take care of:
//   Equal()
//   Exists()
//   Changed()

type nodebase struct {
	name string
	action Action
	state NodeState
}

func makenodebase(name string) nodebase {
	return nodebase{
		name: name,
	}
}

func (self *nodebase) Name() string {
	return self.name
}

func (self *nodebase) String() string {
	return self.name
}

func (self *nodebase) SetAction(action Action) {
	self.action = action
}

func (self *nodebase) Action() Action {
	return self.action
}

func (self *nodebase) Expand(dag *DAG, ns types.Namespace) ([]Node, error) {
	return nil, nil
}

func (self *nodebase) SetState(state NodeState) {
	self.state = state
}

func (self *nodebase) State() NodeState {
	return self.state
}
